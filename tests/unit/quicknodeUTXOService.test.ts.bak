/**
 * @fileoverview Tests for QuicknodeUTXOService with mocked bitcoinjs-lib
 * Tests address validation, script derivation, and UTXO fetching logic
 */

import { assertEquals, assertExists } from "@std/assert";
import { beforeEach, describe, it } from "@std/testing/bdd";

// Set test environment
(globalThis as any).SKIP_REDIS_CONNECTION = true;
Deno.env.set("SKIP_REDIS_CONNECTION", "true");
Deno.env.set("DENO_ENV", "test");

// Mock bitcoinjs-lib imports using the mock implementation
import { mockBitcoinJSLib } from "../mocks/bitcoinjs-lib.mock.ts";
const bitcoinMock = mockBitcoinJSLib();

// Patch the imports for the service under test
const originalModules = new Map();
beforeEach(async () => {
  // Store original modules
  const bitcoinjsModule = await import("bitcoinjs-lib");
  originalModules.set("bitcoinjs-lib", bitcoinjsModule);

  // Replace with mocks
  globalThis.mockBitcoinJS = bitcoinMock;
});

import {
  QuicknodeUTXOService,
  type UTXOOptions,
} from "$server/services/quicknode/quicknodeUTXOService.ts";

// Mock CachedQuicknodeRPCService
class MockCachedQuicknodeRPCService {
  private static mockResponses = new Map();
  private static shouldFail = false;
  private static failureCount = 0;
  private static maxFailures = 0;

  static setMockResponse(method: string, params: any[], response: any) {
    const key = `${method}:${JSON.stringify(params)}`;
    this.mockResponses.set(key, response);
  }

  static clearMockResponses() {
    this.mockResponses.clear();
  }

  static setShouldFail(shouldFail: boolean, maxFailures = 0) {
    this.shouldFail = shouldFail;
    this.failureCount = 0;
    this.maxFailures = maxFailures;
  }

  static async executeRPC<T>(
    method: string,
    params: any[],
    _cacheDuration?: number,
  ): Promise<{ result?: T; error?: any }> {
    await Promise.resolve(); // Simulate async operation

    if (this.shouldFail && this.failureCount < this.maxFailures) {
      this.failureCount++;
      return { error: "Mock RPC failure" };
    }

    const key = `${method}:${JSON.stringify(params)}`;
    const mockResponse = this.mockResponses.get(key);

    if (mockResponse) {
      return mockResponse;
    }

    // Default responses for common methods
    if (method === "bb_getTxSpecific") {
      return {
        result: {
          txid: params[0],
          size: 250,
          vsize: 141,
          weight: 561,
          fee: 2500,
          fee_rate: 17.7,
          height: 744067,
          vin: [{ sequence: 0xfffffffd, coinbase: false }],
          vout: [
            {
              value: 0.44089800, // BTC value
              n: 0,
              scriptPubKey: {
                asm: "0 c7e20a5dd06b5e3b8f8d5e3b5a8e1c6d9e2f3a4b",
                desc:
                  "wpkh([fingerprint]c7e20a5dd06b5e3b8f8d5e3b5a8e1c6d9e2f3a4b)",
                hex: "0014c7e20a5dd06b5e3b8f8d5e3b5a8e1c6d9e2f3a4b",
                address: "bc1qcvq650ddrvmq9a7m5ezltsk9wyh8epwlhzc8f2",
                type: "witness_v0_keyhash",
              },
            },
          ],
          confirmations: 160738,
          time: 1681234567,
          blocktime: 1681234567,
        },
      };
    }

    if (method === "bb_getUTXOs") {
      return {
        result: [
          {
            txid:
              "a0a34578b86c5ed1720083e0008e0578a744a9daa8c13124f64fb8ebbae9029b",
            vout: 0,
            value: "44089800", // String satoshi value
            confirmations: 160738,
            height: 744067,
            coinbase: false,
          },
          {
            txid:
              "ee9ee0c0c1de2591dc5b04c528ba60b3609d5c78ca0303d81a17e81f908a962d",
            vout: 1,
            value: "546", // Dust amount
            confirmations: 160738,
            height: 744067,
            coinbase: false,
          },
        ],
      };
    }

    return { error: `No mock response for ${method}` };
  }
}

// Note: This test requires extensive mocking infrastructure for proper isolation
// The QuicknodeUTXOService has deep dependencies on CachedQuicknodeRPCService
// which would need module-level mocking to properly test in isolation.
// For now, this test demonstrates the bitcoinjs-lib mock usage pattern.
globalThis.mockCachedQuicknodeRPCService = MockCachedQuicknodeRPCService;

describe("QuicknodeUTXOService", () => {
  beforeEach(() => {
    MockCachedQuicknodeRPCService.clearMockResponses();
    MockCachedQuicknodeRPCService.setShouldFail(false);
  });

  describe("getUTXO", () => {
    it("should fetch single UTXO with valid address validation", async () => {
      const txid =
        "a0a34578b86c5ed1720083e0008e0578a744a9daa8c13124f64fb8ebbae9029b";
      const vout = 0;

      // Mock the transaction response
      MockCachedQuicknodeRPCService.setMockResponse(
        "bb_getTxSpecific",
        [txid],
        {
          result: {
            txid,
            size: 250,
            vsize: 141,
            weight: 561,
            fee: 2500,
            fee_rate: 17.7,
            height: 744067,
            vin: [{ sequence: 0xfffffffd, coinbase: false }],
            vout: [
              {
                value: 0.44089800, // BTC value
                n: 0,
                scriptPubKey: {
                  asm: "0 c7e20a5dd06b5e3b8f8d5e3b5a8e1c6d9e2f3a4b",
                  desc:
                    "wpkh([fingerprint]c7e20a5dd06b5e3b8f8d5e3b5a8e1c6d9e2f3a4b)",
                  hex: "0014c7e20a5dd06b5e3b8f8d5e3b5a8e1c6d9e2f3a4b",
                  address: "bc1qcvq650ddrvmq9a7m5ezltsk9wyh8epwlhzc8f2",
                  type: "witness_v0_keyhash",
                },
              },
            ],
            confirmations: 160738,
            time: 1681234567,
            blocktime: 1681234567,
          },
        },
      );

      const result = await QuicknodeUTXOService.getUTXO(txid, vout);

      assertEquals(result.error, undefined);
      assertExists(result.data);
      assertEquals(result.data!.txid, txid);
      assertEquals(result.data!.vout, vout);
      assertEquals(result.data!.value, 44089800); // Converted to satoshis
      assertEquals(result.data!.script, "0014c7e20a5dd06b5e3b5a8e1c6d9e2f3a4b");
      assertEquals(result.data!.scriptType, "p2wpkh");
    });

    it("should handle invalid address format", async () => {
      const txid = "invalid_address_test";
      const vout = 0;

      // Mock response with invalid address
      MockCachedQuicknodeRPCService.setMockResponse(
        "bb_getTxSpecific",
        [txid],
        {
          result: {
            txid,
            size: 250,
            vsize: 141,
            weight: 561,
            vout: [
              {
                value: 0.001,
                n: 0,
                scriptPubKey: {
                  hex: "0014invalidhex",
                  address: "invalid_address_format",
                  type: "witness_v0_keyhash",
                },
              },
            ],
          },
        },
      );

      const result = await QuicknodeUTXOService.getUTXO(txid, vout);

      // Should handle invalid address gracefully
      assertExists(result.error);
    });

    it("should fallback to QuickNode hex when address derivation fails", async () => {
      const txid = "fallback_hex_test";
      const vout = 0;

      MockCachedQuicknodeRPCService.setMockResponse(
        "bb_getTxSpecific",
        [txid],
        {
          result: {
            txid,
            size: 250,
            vsize: 141,
            weight: 561,
            vout: [
              {
                value: 0.001,
                n: 0,
                scriptPubKey: {
                  hex: "76a914deadbeefdeadbeefdeadbeefdeadbeefdeadbeef88ac", // Valid P2PKH hex
                  address: "", // Empty address to trigger fallback
                  type: "pubkeyhash",
                },
              },
            ],
          },
        },
      );

      const result = await QuicknodeUTXOService.getUTXO(txid, vout);

      assertEquals(result.error, undefined);
      assertExists(result.data);
      assertEquals(
        result.data!.script,
        "76a914deadbeefdeadbeefdeadbeefdeadbeefdeadbeef88ac",
      );
    });

    it("should include ancestor info when requested", async () => {
      const txid = "ancestor_test";
      const vout = 0;

      MockCachedQuicknodeRPCService.setMockResponse(
        "bb_getTxSpecific",
        [txid],
        {
          result: {
            txid,
            size: 250,
            vsize: 141,
            weight: 561,
            fee: 2500,
            fee_rate: 17.7,
            height: 744067,
            vin: [{ sequence: 0xfffffffd, coinbase: false }],
            vout: [
              {
                value: 0.001,
                n: 0,
                scriptPubKey: {
                  hex: "0014c7e20a5dd06b5e3b8f8d5e3b5a8e1c6d9e2f3a4b",
                  address: "bc1qcvq650ddrvmq9a7m5ezltsk9wyh8epwlhzc8f2",
                  type: "witness_v0_keyhash",
                },
              },
            ],
            confirmations: 160738,
          },
        },
      );

      const result = await QuicknodeUTXOService.getUTXO(txid, vout, true);

      assertEquals(result.error, undefined);
      assertExists(result.data);
      assertExists(result.data!.ancestor);
      assertEquals(result.data!.ancestor!.fees, 2500);
      assertEquals(result.data!.ancestor!.effectiveRate, 17.7);
      assertEquals(result.data!.ancestor!.blockHeight, 744067);
    });

    it("should handle RPC errors gracefully", async () => {
      MockCachedQuicknodeRPCService.setShouldFail(true, 1);

      const result = await QuicknodeUTXOService.getUTXO("error_test", 0);

      assertExists(result.error);
      assertEquals(result.data, undefined);
    });

    it("should validate script/address consistency", async () => {
      const txid = "consistency_test";
      const vout = 0;

      // Mock response with inconsistent script and address
      MockCachedQuicknodeRPCService.setMockResponse(
        "bb_getTxSpecific",
        [txid],
        {
          result: {
            txid,
            vout: [
              {
                value: 0.001,
                n: 0,
                scriptPubKey: {
                  hex: "0014aaaabbbbccccddddeeeeffffaaaabbbbccccdddd", // Different from what address derives
                  address: "bc1qcvq650ddrvmq9a7m5ezltsk9wyh8epwlhzc8f2",
                  type: "witness_v0_keyhash",
                },
              },
            ],
          },
        },
      );

      const result = await QuicknodeUTXOService.getUTXO(txid, vout);

      // Should detect mismatch and force fallback
      assertExists(result.error);
      assertEquals(result.error, "QuickNode script/address mismatch");
    });
  });

  describe("getUTXOs", () => {
    it("should fetch multiple UTXOs for an address", async () => {
      const address = "bc1qcvq650ddrvmq9a7m5ezltsk9wyh8epwlhzc8f2";

      const result = await QuicknodeUTXOService.getUTXOs(address);

      assertEquals(result.error, undefined);
      assertExists(result.data);
      assertEquals(result.data!.length, 2);

      // Check first UTXO
      assertEquals(
        result.data![0].txid,
        "a0a34578b86c5ed1720083e0008e0578a744a9daa8c13124f64fb8ebbae9029b",
      );
      assertEquals(result.data![0].value, 44089800);

      // Check second UTXO (dust amount)
      assertEquals(
        result.data![1].txid,
        "ee9ee0c0c1de2591dc5b04c528ba60b3609d5c78ca0303d81a17e81f908a962d",
      );
      assertEquals(result.data![1].value, 546);
    });

    it("should handle confirmed only option", async () => {
      const address = "bc1qtest";
      const options: UTXOOptions = { confirmedOnly: true };

      // Mock the RPC call with confirmed only parameter
      MockCachedQuicknodeRPCService.setMockResponse(
        "bb_getUTXOs",
        [address, { confirmed: true }],
        {
          result: [
            {
              txid: "confirmed_utxo",
              vout: 0,
              value: "100000",
              confirmations: 6,
              height: 744067,
              coinbase: false,
            },
          ],
        },
      );

      const result = await QuicknodeUTXOService.getUTXOs(address, options);

      assertEquals(result.error, undefined);
      assertExists(result.data);
      assertEquals(result.data!.length, 1);
      assertEquals(result.data![0].txid, "confirmed_utxo");
    });

    it("should handle RPC errors in getUTXOs", async () => {
      MockCachedQuicknodeRPCService.setShouldFail(true, 1);

      const result = await QuicknodeUTXOService.getUTXOs("error_address");

      assertExists(result.error);
      assertEquals(result.data, undefined);
    });
  });

  describe("getRawTransactionHex", () => {
    it("should fetch raw transaction hex", async () => {
      const txid = "raw_tx_test";
      const expectedHex =
        "020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff";

      MockCachedQuicknodeRPCService.setMockResponse(
        "getrawtransaction",
        [txid, 0],
        {
          result: expectedHex,
        },
      );

      const result = await QuicknodeUTXOService.getRawTransactionHex(txid);

      assertEquals(result.error, undefined);
      assertEquals(result.data, expectedHex);
    });

    it("should handle raw transaction fetch errors", async () => {
      MockCachedQuicknodeRPCService.setShouldFail(true, 1);

      const result = await QuicknodeUTXOService.getRawTransactionHex(
        "error_tx",
      );

      assertExists(result.error);
    });

    it("should handle invalid response format", async () => {
      const txid = "invalid_response_test";

      MockCachedQuicknodeRPCService.setMockResponse(
        "getrawtransaction",
        [txid, 0],
        {
          result: { invalid: "format" }, // Should be string
        },
      );

      const result = await QuicknodeUTXOService.getRawTransactionHex(txid);

      assertExists(result.error);
      assertEquals(
        result.error,
        "Invalid response format for raw transaction hex",
      );
    });
  });

  describe("Address Validation with bitcoinjs-lib Mock", () => {
    it("should handle different address types with mock validation", async () => {
      const testCases = [
        {
          address: "bc1qmockaddress123456789",
          scriptType: "p2wpkh",
          expectedScript: "0014cafebabe".repeat(5).slice(0, 44),
        },
        {
          address: "bc1pmockaddress123456789012345678901234567890",
          scriptType: "p2tr",
          expectedScript: "5120deadbeef".repeat(8).slice(0, 68),
        },
        {
          address: "1MockAddress123456789",
          scriptType: "p2pkh",
          expectedScript: "76a914feedface".repeat(5).slice(0, 50) + "88ac",
        },
        {
          address: "3MockAddress123456789",
          scriptType: "p2sh",
          expectedScript: "a914beefdead".repeat(5).slice(0, 46) + "87",
        },
      ];

      for (const testCase of testCases) {
        const txid = `${testCase.scriptType}_test`;
        const vout = 0;

        MockCachedQuicknodeRPCService.setMockResponse(
          "bb_getTxSpecific",
          [txid],
          {
            result: {
              txid,
              vout: [
                {
                  value: 0.001,
                  n: 0,
                  scriptPubKey: {
                    hex: testCase.expectedScript,
                    address: testCase.address,
                    type: testCase.scriptType,
                  },
                },
              ],
            },
          },
        );

        const result = await QuicknodeUTXOService.getUTXO(txid, vout);

        assertEquals(result.error, undefined);
        assertExists(result.data);
        assertEquals(result.data!.scriptType, testCase.scriptType);
      }
    });

    it("should handle mock address validation errors", async () => {
      const txid = "invalid_mock_address_test";
      const vout = 0;

      MockCachedQuicknodeRPCService.setMockResponse(
        "bb_getTxSpecific",
        [txid],
        {
          result: {
            txid,
            vout: [
              {
                value: 0.001,
                n: 0,
                scriptPubKey: {
                  hex: "",
                  address: "invalid_format_that_will_fail_validation",
                  type: "unknown",
                },
              },
            ],
          },
        },
      );

      const result = await QuicknodeUTXOService.getUTXO(txid, vout);

      assertExists(result.error);
    });
  });

  describe("Error Handling and Edge Cases", () => {
    it("should handle missing vout in transaction", async () => {
      const txid = "missing_vout_test";
      const vout = 5; // Index beyond available outputs

      MockCachedQuicknodeRPCService.setMockResponse(
        "bb_getTxSpecific",
        [txid],
        {
          result: {
            txid,
            vout: [
              {
                value: 0.001,
                n: 0,
                scriptPubKey: {
                  hex: "0014c7e20a5dd06b5e3b8f8d5e3b5a8e1c6d9e2f3a4b",
                  address: "bc1qcvq650ddrvmq9a7m5ezltsk9wyh8epwlhzc8f2",
                  type: "witness_v0_keyhash",
                },
              },
            ],
          },
        },
      );

      const result = await QuicknodeUTXOService.getUTXO(txid, vout);

      assertExists(result.error);
      assertEquals(
        result.error,
        `UTXO ${txid}:${vout} not found in tx.vout array`,
      );
    });

    it("should handle empty script and address", async () => {
      const txid = "empty_script_test";
      const vout = 0;

      MockCachedQuicknodeRPCService.setMockResponse(
        "bb_getTxSpecific",
        [txid],
        {
          result: {
            txid,
            vout: [
              {
                value: 0.001,
                n: 0,
                scriptPubKey: {
                  hex: "",
                  address: "",
                  type: "unknown",
                },
              },
            ],
          },
        },
      );

      const result = await QuicknodeUTXOService.getUTXO(txid, vout);

      assertExists(result.error);
      assertEquals(
        result.error,
        `Neither script hex nor address from QN for ${txid}:${vout}.`,
      );
    });

    it("should handle exception in catch block", async () => {
      // Force an exception by making the service throw
      const txid = "exception_test";
      const vout = 0;

      MockCachedQuicknodeRPCService.setMockResponse(
        "bb_getTxSpecific",
        [txid],
        {
          error: new Error("Network failure"),
        },
      );

      const result = await QuicknodeUTXOService.getUTXO(txid, vout);

      assertExists(result.error);
    });
  });

  describe("Bitcoin Value Conversion", () => {
    it("should correctly convert BTC to satoshis", async () => {
      const testCases = [
        { btc: 1.0, expectedSats: 100000000 },
        { btc: 0.00000001, expectedSats: 1 }, // 1 satoshi
        { btc: 0.44089800, expectedSats: 44089800 },
        { btc: 21.0, expectedSats: 2100000000 }, // Max supply
      ];

      for (let i = 0; i < testCases.length; i++) {
        const testCase = testCases[i];
        const txid = `conversion_test_${i}`;
        const vout = 0;

        MockCachedQuicknodeRPCService.setMockResponse(
          "bb_getTxSpecific",
          [txid],
          {
            result: {
              txid,
              vout: [
                {
                  value: testCase.btc,
                  n: 0,
                  scriptPubKey: {
                    hex: "0014c7e20a5dd06b5e3b8f8d5e3b5a8e1c6d9e2f3a4b",
                    address: "bc1qcvq650ddrvmq9a7m5ezltsk9wyh8epwlhzc8f2",
                    type: "witness_v0_keyhash",
                  },
                },
              ],
            },
          },
        );

        const result = await QuicknodeUTXOService.getUTXO(txid, vout);

        assertEquals(result.error, undefined);
        assertExists(result.data);
        assertEquals(result.data!.value, testCase.expectedSats);
      }
    });
  });
});
