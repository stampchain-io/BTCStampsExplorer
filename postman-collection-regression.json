{
  "info": {
    "name": "BTC Stamps Explorer API - Working Dual Endpoint Testing",
    "description": "Fixed dual endpoint comparison with reliable data filters for dev/prod database differences",
    "version": "2.1.0",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "variable": [
    {
      "key": "health_dev_response",
      "value": "",
      "type": "string"
    },
    {
      "key": "health_prod_response", 
      "value": "",
      "type": "string"
    },
    {
      "key": "health_dev_time",
      "value": "",
      "type": "string"
    },
    {
      "key": "health_prod_time",
      "value": "",
      "type": "string"
    },
    {
      "key": "version_dev_response",
      "value": "",
      "type": "string"
    },
    {
      "key": "version_prod_response",
      "value": "",
      "type": "string"
    },
    {
      "key": "version_dev_time",
      "value": "",
      "type": "string"
    },
    {
      "key": "version_prod_time",
      "value": "",
      "type": "string"
    },
    {
      "key": "stamps_dev_response",
      "value": "",
      "type": "string"
    },
    {
      "key": "stamps_prod_response",
      "value": "",
      "type": "string"
    },
    {
      "key": "stamps_dev_time",
      "value": "",
      "type": "string"
    },
    {
      "key": "stamps_prod_time",
      "value": "",
      "type": "string"
    },
    {
      "key": "block_dev_response",
      "value": "",
      "type": "string"
    },
    {
      "key": "block_prod_response",
      "value": "",
      "type": "string"
    },
    {
      "key": "block_dev_time",
      "value": "",
      "type": "string"
    },
    {
      "key": "block_prod_time",
      "value": "",
      "type": "string"
    }
  ],
  "item": [
    {
      "name": "1. Health Check - Development",
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "http://host.docker.internal:8000/api/v2/health",
          "host": ["http://host.docker.internal:8000"],
          "path": ["api", "v2", "health"]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• Health Dev Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "// Store dev response data",
              "pm.collectionVariables.set('health_dev_response', pm.response.text());",
              "pm.collectionVariables.set('health_dev_time', pm.response.responseTime);",
              "",
              "pm.test('Health Dev - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});"
            ]
          }
        }
      ]
    },
    {
      "name": "2. Health Check - Production", 
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "https://stampchain.io/api/v2/health",
          "host": ["https://stampchain.io"],
          "path": ["api", "v2", "health"]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• Health Prod Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "// Store prod response data", 
              "pm.collectionVariables.set('health_prod_response', pm.response.text());",
              "pm.collectionVariables.set('health_prod_time', pm.response.responseTime);",
              "",
              "pm.test('Health Prod - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// Compare responses now that we have both",
              "const devResponse = pm.collectionVariables.get('health_dev_response');",
              "const prodResponse = pm.collectionVariables.get('health_prod_response');",
              "const devTime = parseInt(pm.collectionVariables.get('health_dev_time'));",
              "const prodTime = parseInt(pm.collectionVariables.get('health_prod_time'));",
              "",
              "console.log('üîç HEALTH ENDPOINT COMPARISON:');",
              "console.log('  Dev Time:', devTime + 'ms');", 
              "console.log('  Prod Time:', prodTime + 'ms');",
              "console.log('  Performance Diff:', Math.abs(devTime - prodTime) + 'ms');",
              "",
              "if (devResponse && prodResponse) {",
              "    try {",
              "        const devJson = JSON.parse(devResponse);",
              "        const prodJson = JSON.parse(prodResponse);",
              "        ",
              "        // Deep schema comparison",
              "        const schemaComparison = compareSchemas(devJson, prodJson, 'root');",
              "        ",
              "        if (schemaComparison.length === 0) {",
              "            console.log('  ‚úÖ Schemas identical');",
              "        } else {",
              "            console.log('  üö® SCHEMA DIFFERENCES DETECTED:');",
              "            schemaComparison.forEach(diff => {",
              "                console.log(`    ${diff.type}: ${diff.path}`);",
              "                if (diff.details) console.log(`      ${diff.details}`);",
              "            });",
              "        }",
              "        ",
              "        // Store for final report aggregation",
              "        pm.collectionVariables.set('health_schema_differences', JSON.stringify(schemaComparison));",
              "    } catch (e) {",
              "        console.log('  ‚ö†Ô∏è Could not parse JSON responses for comparison');",
              "    }",
              "} else {",
              "    console.log('  ‚ùå Missing response data for comparison');",
              "}",
              "",
              "// Deep schema comparison function",
              "function compareSchemas(dev, prod, path) {",
              "    const differences = [];",
              "    ",
              "    // Type comparison",
              "    const devType = getDataType(dev);",
              "    const prodType = getDataType(prod);",
              "    ",
              "    if (devType !== prodType) {",
              "        differences.push({",
              "            type: 'TYPE_CHANGE',",
              "            path: path,",
              "            details: `${devType} ‚Üí ${prodType}`",
              "        });",
              "        return differences; // Stop here if types differ",
              "    }",
              "    ",
              "    // Handle objects",
              "    if (devType === 'object') {",
              "        const devKeys = Object.keys(dev);",
              "        const prodKeys = Object.keys(prod);",
              "        const allKeys = new Set([...devKeys, ...prodKeys]);",
              "        ",
              "        for (const key of allKeys) {",
              "            const newPath = path === 'root' ? key : `${path}.${key}`;",
              "            ",
              "            if (!(key in dev)) {",
              "                differences.push({",
              "                    type: 'FIELD_ADDED',",
              "                    path: newPath,",
              "                    details: `New in production: ${getDataType(prod[key])}`",
              "                });",
              "            } else if (!(key in prod)) {",
              "                differences.push({",
              "                    type: 'FIELD_REMOVED',",
              "                    path: newPath,",
              "                    details: `Removed from production: ${getDataType(dev[key])}`",
              "                });",
              "            } else {",
              "                differences.push(...compareSchemas(dev[key], prod[key], newPath));",
              "            }",
              "        }",
              "    }",
              "    ",
              "    // Handle arrays",
              "    else if (devType === 'array') {",
              "        if (dev.length > 0 && prod.length > 0) {",
              "            // Compare first element structure",
              "            const newPath = `${path}[0]`;",
              "            differences.push(...compareSchemas(dev[0], prod[0], newPath));",
              "        }",
              "    }",
              "    ",
              "    return differences;",
              "}",
              "",
              "function getDataType(value) {",
              "    if (value === null) return 'null';",
              "    if (Array.isArray(value)) return 'array';",
              "    if (typeof value === 'object') return 'object';",
              "    if (typeof value === 'string') {",
              "        // Check if it's a numeric string",
              "        if (/^\\d+$/.test(value)) return 'string(numeric)';",
              "        if (/^\\d+\\.\\d+$/.test(value)) return 'string(decimal)';",
              "        return 'string';",
              "    }",
              "    return typeof value;",
              "}"
            ]
          }
        }
      ]
    },
    {
      "name": "3. Version - Development",
      "request": {
        "method": "GET", 
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "http://host.docker.internal:8000/api/v2/version",
          "host": ["http://host.docker.internal:8000"],
          "path": ["api", "v2", "version"]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• Version Dev Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "// Store dev response data",
              "pm.collectionVariables.set('version_dev_response', pm.response.text());",
              "pm.collectionVariables.set('version_dev_time', pm.response.responseTime);",
              "",
              "pm.test('Version Dev - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});"
            ]
          }
        }
      ]
    },
    {
      "name": "4. Version - Production",
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept", 
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "https://stampchain.io/api/v2/version",
          "host": ["https://stampchain.io"],
          "path": ["api", "v2", "version"]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• Version Prod Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "// Store prod response data",
              "pm.collectionVariables.set('version_prod_response', pm.response.text());",
              "pm.collectionVariables.set('version_prod_time', pm.response.responseTime);",
              "",
              "pm.test('Version Prod - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// Compare responses",
              "const devResponse = pm.collectionVariables.get('version_dev_response');",
              "const prodResponse = pm.collectionVariables.get('version_prod_response');",
              "const devTime = parseInt(pm.collectionVariables.get('version_dev_time'));",
              "const prodTime = parseInt(pm.collectionVariables.get('version_prod_time'));",
              "",
              "console.log('üîç VERSION ENDPOINT COMPARISON:');",
              "console.log('  Dev Time:', devTime + 'ms');",
              "console.log('  Prod Time:', prodTime + 'ms');", 
              "console.log('  Performance Diff:', Math.abs(devTime - prodTime) + 'ms');",
              "",
              "if (devResponse && prodResponse) {",
              "    console.log('  Dev Response:', devResponse);",
              "    console.log('  Prod Response:', prodResponse);",
              "    ",
              "    try {",
              "        const devJson = JSON.parse(devResponse);",
              "        const prodJson = JSON.parse(prodResponse);",
              "        ",
              "        // Deep schema comparison for version object",
              "        const versionSchemaComparison = compareSchemas(devJson, prodJson, 'version');",
              "        ",
              "        if (versionSchemaComparison.length === 0) {",
              "            console.log('  ‚úÖ Version schemas identical');",
              "        } else {",
              "            console.log('  üö® VERSION SCHEMA DIFFERENCES:');",
              "            versionSchemaComparison.forEach(diff => {",
              "                console.log(`    ${diff.type}: ${diff.path}`);",
              "                if (diff.details) console.log(`      ${diff.details}`);",
              "            });",
              "        }",
              "        ",
              "        // Store for final report aggregation",
              "        pm.collectionVariables.set('version_schema_differences', JSON.stringify(versionSchemaComparison));",
              "    } catch (e) {",
              "        // Fallback to string comparison for non-JSON responses",
              "        if (devResponse.trim() === prodResponse.trim()) {",
              "            console.log('  ‚úÖ Responses identical (string)');",
              "        } else {",
              "            console.log('  ‚ö†Ô∏è Responses differ (string)');",
              "        }",
              "    }",
              "} else {",
              "    console.log('  ‚ùå Missing response data for comparison');",
              "}"
            ]
          }
        }
      ]
    },
    {
      "name": "5. Early Stamps (Reliable Data) - Development",
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "http://host.docker.internal:8000/api/v2/stamps?limit=1&page=1&sort_order=asc&block_index_min=779652&block_index_max=780000",
          "host": ["http://host.docker.internal:8000"],
          "path": ["api", "v2", "stamps"],
          "query": [
            {
              "key": "limit",
              "value": "1",
              "description": "Small result set for comparison"
            },
            {
              "key": "page", 
              "value": "1",
              "description": "First page"
            },
            {
              "key": "sort_order",
              "value": "asc",
              "description": "Oldest stamps first for consistency"
            },
            {
              "key": "block_index_min",
              "value": "779652",
              "description": "Genesis block for stamps - guaranteed to exist"
            },
            {
              "key": "block_index_max",
              "value": "780000", 
              "description": "Early reliable range"
            }
          ]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• Stamps Dev Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "// Store dev response data",
              "pm.collectionVariables.set('stamps_dev_response', pm.response.text());",
              "pm.collectionVariables.set('stamps_dev_time', pm.response.responseTime);",
              "",
              "pm.test('Stamps Dev - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// Validate we got data",
              "if (pm.response.code === 200) {",
              "    try {",
              "        const responseData = pm.response.json();",
              "        pm.test('Stamps Dev - Has data in reliable range', function () {",
              "            pm.expect(responseData.data).to.be.an('array');",
              "        });",
              "    } catch (e) {",
              "        console.log('Could not parse stamps response');",
              "    }",
              "}"
            ]
          }
        }
      ]
    },
    {
      "name": "6. Early Stamps (Reliable Data) - Production",
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "https://stampchain.io/api/v2/stamps?limit=1&page=1&sort_order=asc&block_index_min=779652&block_index_max=780000",
          "host": ["https://stampchain.io"],
          "path": ["api", "v2", "stamps"],
          "query": [
            {
              "key": "limit",
              "value": "1",
              "description": "Small result set for comparison"
            },
            {
              "key": "page",
              "value": "1", 
              "description": "First page"
            },
            {
              "key": "sort_order",
              "value": "asc",
              "description": "Oldest stamps first for consistency"
            },
            {
              "key": "block_index_min",
              "value": "779652",
              "description": "Genesis block for stamps - guaranteed to exist"
            },
            {
              "key": "block_index_max",
              "value": "780000",
              "description": "Early reliable range"
            }
          ]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• Stamps Prod Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "// Store prod response data",
              "pm.collectionVariables.set('stamps_prod_response', pm.response.text());",
              "pm.collectionVariables.set('stamps_prod_time', pm.response.responseTime);",
              "",
              "pm.test('Stamps Prod - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// Compare responses with reliable data",
              "const devResponse = pm.collectionVariables.get('stamps_dev_response');",
              "const prodResponse = pm.collectionVariables.get('stamps_prod_response');",
              "const devTime = parseInt(pm.collectionVariables.get('stamps_dev_time'));",
              "const prodTime = parseInt(pm.collectionVariables.get('stamps_prod_time'));",
              "",
              "console.log('üîç STAMPS ENDPOINT COMPARISON (Reliable Data):');",
              "console.log('  Dev Time:', devTime + 'ms');",
              "console.log('  Prod Time:', prodTime + 'ms');",
              "console.log('  Performance Diff:', Math.abs(devTime - prodTime) + 'ms');",
              "",
              "if (devResponse && prodResponse) {",
              "    try {",
              "        const devJson = JSON.parse(devResponse);",
              "        const prodJson = JSON.parse(prodResponse);",
              "        ",
              "        // Compare data structure",
              "        const devHasData = devJson.data && devJson.data.length > 0;",
              "        const prodHasData = prodJson.data && prodJson.data.length > 0;",
              "        ",
              "        console.log('  Dev has data:', devHasData);",
              "        console.log('  Prod has data:', prodHasData);",
              "        ",
              "        if (devHasData && prodHasData) {",
              "            const devStamp = devJson.data[0];",
              "            const prodStamp = prodJson.data[0];",
              "            ",
              "            if (devStamp.stamp_id === prodStamp.stamp_id) {",
              "                console.log('  ‚úÖ Same stamp returned:', devStamp.stamp_id);",
              "                ",
              "                // Deep schema comparison of stamp objects",
              "                const stampSchemaComparison = compareSchemas(devStamp, prodStamp, 'stamp');",
              "                if (stampSchemaComparison.length === 0) {",
              "                    console.log('  ‚úÖ Stamp schema identical');",
              "                } else {",
              "                    console.log('  üö® STAMP SCHEMA DIFFERENCES:');",
              "                    stampSchemaComparison.forEach(diff => {",
              "                        console.log(`    ${diff.type}: ${diff.path}`);",
              "                        if (diff.details) console.log(`      ${diff.details}`);",
              "                    });",
              "                }",
              "                ",
              "                // Store for final report aggregation",
              "                pm.collectionVariables.set('stamps_schema_differences', JSON.stringify(stampSchemaComparison));",
              "            } else {",
              "                console.log('  ‚ö†Ô∏è Different stamps returned');",
              "                console.log('    Dev:', devStamp.stamp_id);",
              "                console.log('    Prod:', prodStamp.stamp_id);",
              "                console.log('  ‚ö†Ô∏è Cannot compare schemas - different records');",
              "            }",
              "            ",
              "            // Performance regression analysis",
              "            const perfRatio = Math.max(devTime, prodTime) / Math.min(devTime, prodTime);",
              "            if (perfRatio > 50) {",
              "                console.log('  üö® CRITICAL: >50x performance difference!');",
              "            } else if (perfRatio > 10) {",
              "                console.log('  ‚ö†Ô∏è WARNING: >10x performance difference');",
              "            }",
              "        } else {",
              "            if (!devHasData) console.log('  ‚ùå Dev missing data in reliable range');",
              "            if (!prodHasData) console.log('  ‚ùå Prod missing data in reliable range');",
              "        }",
              "    } catch (e) {",
              "        console.log('  ‚ö†Ô∏è Could not parse stamps responses for comparison');",
              "    }",
              "} else {",
              "    console.log('  ‚ùå Missing response data for comparison');",
              "}"
            ]
          }
        }
      ]
    },
    {
      "name": "7. Known Block (Reliable) - Development",
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "http://host.docker.internal:8000/api/v2/blocks/779652",
          "host": ["http://host.docker.internal:8000"],
          "path": ["api", "v2", "blocks", "779652"]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• Block Dev Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "// Store dev response data",
              "pm.collectionVariables.set('block_dev_response', pm.response.text());",
              "pm.collectionVariables.set('block_dev_time', pm.response.responseTime);",
              "",
              "pm.test('Block Dev - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});"
            ]
          }
        }
      ]
    },
    {
      "name": "8. Known Block (Reliable) - Production",
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "https://stampchain.io/api/v2/blocks/779652",
          "host": ["https://stampchain.io"],
          "path": ["api", "v2", "blocks", "779652"]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• Block Prod Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "// Store prod response data",
              "pm.collectionVariables.set('block_prod_response', pm.response.text());",
              "pm.collectionVariables.set('block_prod_time', pm.response.responseTime);",
              "",
              "pm.test('Block Prod - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// Compare responses",
              "const devResponse = pm.collectionVariables.get('block_dev_response');",
              "const prodResponse = pm.collectionVariables.get('block_prod_response');",
              "const devTime = parseInt(pm.collectionVariables.get('block_dev_time'));",
              "const prodTime = parseInt(pm.collectionVariables.get('block_prod_time'));",
              "",
              "console.log('üîç BLOCK ENDPOINT COMPARISON (Block 779652 - Genesis):');",
              "console.log('  Dev Time:', devTime + 'ms');",
              "console.log('  Prod Time:', prodTime + 'ms');",
              "console.log('  Performance Diff:', Math.abs(devTime - prodTime) + 'ms');",
              "",
              "if (devResponse && prodResponse) {",
              "    try {",
              "        const devJson = JSON.parse(devResponse);",
              "        const prodJson = JSON.parse(prodResponse);",
              "        ",
              "        // Compare key block properties first",
              "        const devBlockIndex = devJson.block_index;",
              "        const prodBlockIndex = prodJson.block_index;",
              "        const devBlockHash = devJson.block_hash;",
              "        const prodBlockHash = prodJson.block_hash;",
              "        ",
              "        console.log('  Dev block_index:', devBlockIndex);",
              "        console.log('  Prod block_index:', prodBlockIndex);",
              "        ",
              "        if (devBlockIndex === prodBlockIndex && devBlockHash === prodBlockHash) {",
              "            console.log('  ‚úÖ Block identifiers match');",
              "            ",
              "            // Deep schema comparison for entire block object",
              "            const blockSchemaComparison = compareSchemas(devJson, prodJson, 'block');",
              "            if (blockSchemaComparison.length === 0) {",
              "                console.log('  ‚úÖ Block schema identical');",
              "            } else {",
              "                console.log('  üö® BLOCK SCHEMA DIFFERENCES:');",
              "                blockSchemaComparison.forEach(diff => {",
              "                    console.log(`    ${diff.type}: ${diff.path}`);",
              "                    if (diff.details) console.log(`      ${diff.details}`);",
              "                });",
              "            }",
              "            ",
              "            // Store for final report aggregation",
              "            pm.collectionVariables.set('block_schema_differences', JSON.stringify(blockSchemaComparison));",
              "        } else {",
              "            console.log('  ‚ö†Ô∏è Block data differs - fundamental mismatch!');",
              "            if (devBlockIndex !== prodBlockIndex) {",
              "                console.log('    Different block_index:', devBlockIndex, 'vs', prodBlockIndex);",
              "            }",
              "            if (devBlockHash !== prodBlockHash) {",
              "                console.log('    Different block_hash');",
              "            }",
              "        }",
              "    } catch (e) {",
              "        console.log('  ‚ö†Ô∏è Could not parse block responses for comparison');",
              "    }",
              "} else {",
              "    console.log('  ‚ùå Missing response data for comparison');",
              "}"
            ]
          }
        }
      ]
    },
    {
      "name": "9. Critical Balance Endpoint - Development",
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "http://host.docker.internal:8000/api/v2/balance/1GotRejB6XsGgMsM79TvcypeanDJRJbMtg?limit=1",
          "host": ["http://host.docker.internal:8000"],
          "path": ["api", "v2", "balance", "1GotRejB6XsGgMsM79TvcypeanDJRJbMtg"],
          "query": [
            {
              "key": "limit",
              "value": "1",
              "description": "Small result set for performance"
            }
          ]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• Balance Dev Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "pm.collectionVariables.set('balance_dev_response', pm.response.text());",
              "pm.collectionVariables.set('balance_dev_time', pm.response.responseTime);",
              "",
              "pm.test('Balance Dev - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});"
            ]
          }
        }
      ]
    },
    {
      "name": "10. Critical Balance Endpoint - Production",
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "https://stampchain.io/api/v2/balance/1GotRejB6XsGgMsM79TvcypeanDJRJbMtg?limit=1",
          "host": ["https://stampchain.io"],
          "path": ["api", "v2", "balance", "1GotRejB6XsGgMsM79TvcypeanDJRJbMtg"],
          "query": [
            {
              "key": "limit",
              "value": "1", 
              "description": "Small result set for performance"
            }
          ]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• Balance Prod Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "pm.collectionVariables.set('balance_prod_response', pm.response.text());",
              "pm.collectionVariables.set('balance_prod_time', pm.response.responseTime);",
              "",
              "pm.test('Balance Prod - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// Compare critical balance endpoint",
              "const devResponse = pm.collectionVariables.get('balance_dev_response');",
              "const prodResponse = pm.collectionVariables.get('balance_prod_response');",
              "const devTime = parseInt(pm.collectionVariables.get('balance_dev_time'));", 
              "const prodTime = parseInt(pm.collectionVariables.get('balance_prod_time'));",
              "",
              "console.log('üîç BALANCE ENDPOINT COMPARISON (Critical User Workflow):');",
              "console.log('  Dev Time:', devTime + 'ms');",
              "console.log('  Prod Time:', prodTime + 'ms');",
              "console.log('  Performance Diff:', Math.abs(devTime - prodTime) + 'ms');",
              "",
              "if (devResponse && prodResponse) {",
              "    try {",
              "        const devJson = JSON.parse(devResponse);",
              "        const prodJson = JSON.parse(prodResponse);",
              "        ",
              "        const balanceSchemaComparison = compareSchemas(devJson, prodJson, 'balance');",
              "        if (balanceSchemaComparison.length === 0) {",
              "            console.log('  ‚úÖ Balance schema identical');",
              "        } else {",
              "            console.log('  üö® BALANCE SCHEMA DIFFERENCES:');",
              "            balanceSchemaComparison.forEach(diff => {",
              "                console.log(`    ${diff.type}: ${diff.path}`);",
              "                if (diff.details) console.log(`      ${diff.details}`);",
              "            });",
              "        }",
              "        pm.collectionVariables.set('balance_schema_differences', JSON.stringify(balanceSchemaComparison));",
              "    } catch (e) {",
              "        console.log('  ‚ö†Ô∏è Could not parse balance responses for comparison');",
              "    }",
              "} else {",
              "    console.log('  ‚ùå Missing response data for comparison');",
              "}"
            ]
          }
        }
      ]
    },
    {
      "name": "11. SRC20 Tick Info - Development",
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "http://host.docker.internal:8000/api/v2/src20/tick/PEPE?limit=1",
          "host": ["http://host.docker.internal:8000"],
          "path": ["api", "v2", "src20", "tick", "PEPE"],
          "query": [
            {
              "key": "limit",
              "value": "1",
              "description": "Small result for performance"
            }
          ]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• SRC20 Tick Dev Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "pm.collectionVariables.set('src20_tick_dev_response', pm.response.text());",
              "pm.collectionVariables.set('src20_tick_dev_time', pm.response.responseTime);",
              "",
              "pm.test('SRC20 Tick Dev - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});"
            ]
          }
        }
      ]
    },
    {
      "name": "12. SRC20 Tick Info - Production",
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "Accept",
            "value": "application/json"
          }
        ],
        "url": {
          "raw": "https://stampchain.io/api/v2/src20/tick/PEPE?limit=1",
          "host": ["https://stampchain.io"],
          "path": ["api", "v2", "src20", "tick", "PEPE"],
          "query": [
            {
              "key": "limit",
              "value": "1",
              "description": "Small result for performance"
            }
          ]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('üì• SRC20 Tick Prod Response:', pm.response.code, pm.response.responseTime + 'ms');",
              "",
              "pm.collectionVariables.set('src20_tick_prod_response', pm.response.text());",
              "pm.collectionVariables.set('src20_tick_prod_time', pm.response.responseTime);",
              "",
              "pm.test('SRC20 Tick Prod - Status OK', function () {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// Compare SRC20 tick endpoint", 
              "const devResponse = pm.collectionVariables.get('src20_tick_dev_response');",
              "const prodResponse = pm.collectionVariables.get('src20_tick_prod_response');",
              "const devTime = parseInt(pm.collectionVariables.get('src20_tick_dev_time'));",
              "const prodTime = parseInt(pm.collectionVariables.get('src20_tick_prod_time'));",
              "",
              "console.log('üîç SRC20 TICK ENDPOINT COMPARISON (Token Information):');",
              "console.log('  Dev Time:', devTime + 'ms');", 
              "console.log('  Prod Time:', prodTime + 'ms');",
              "console.log('  Performance Diff:', Math.abs(devTime - prodTime) + 'ms');",
              "",
              "if (devResponse && prodResponse) {",
              "    try {",
              "        const devJson = JSON.parse(devResponse);",
              "        const prodJson = JSON.parse(prodResponse);",
              "        ",
              "        const tickSchemaComparison = compareSchemas(devJson, prodJson, 'src20_tick');",
              "        if (tickSchemaComparison.length === 0) {",
              "            console.log('  ‚úÖ SRC20 tick schema identical');",
              "        } else {",
              "            console.log('  üö® SRC20 TICK SCHEMA DIFFERENCES:');",
              "            tickSchemaComparison.forEach(diff => {",
              "                console.log(`    ${diff.type}: ${diff.path}`);",
              "                if (diff.details) console.log(`      ${diff.details}`);",
              "            });",
              "        }",
              "        pm.collectionVariables.set('src20_tick_schema_differences', JSON.stringify(tickSchemaComparison));",
              "    } catch (e) {",
              "        console.log('  ‚ö†Ô∏è Could not parse SRC20 tick responses for comparison');",
              "    }",
              "} else {",
              "    console.log('  ‚ùå Missing response data for comparison');",
              "}"
            ]
          }
        }
      ]
    },
    {
      "name": "13. Final Comparison Report",
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "https://stampchain.io/api/v2/health",
          "host": ["https://stampchain.io"],
          "path": ["api", "v2", "health"]
        }
      },
      "event": [
        {
          "listen": "test",
          "script": {
            "type": "text/javascript",
            "exec": [
              "console.log('\\n' + '='.repeat(80));",
              "console.log('üìä COMPREHENSIVE DUAL ENDPOINT COMPARISON REPORT');",
              "console.log('='.repeat(80));",
              "",
              "// Track schema differences found",
              "let totalSchemaDifferences = 0;",
              "const schemaDifferencesByEndpoint = [];",
              "",
              "// Health endpoint summary",
              "const healthDevTime = parseInt(pm.collectionVariables.get('health_dev_time') || '0');",
              "const healthProdTime = parseInt(pm.collectionVariables.get('health_prod_time') || '0');",
              "console.log('üè• Health Endpoint:');", 
              "console.log('  Dev:', healthDevTime + 'ms | Prod:', healthProdTime + 'ms');",
              "if (healthDevTime && healthProdTime) {",
              "    const healthDiff = Math.abs(healthDevTime - healthProdTime);",
              "    const healthFaster = healthDevTime < healthProdTime ? 'Dev' : 'Prod';",
              "    console.log('  Difference:', healthDiff + 'ms (' + healthFaster + ' faster)');",
              "} else {",
              "    console.log('  ‚ùå Incomplete data');",
              "}",
              "",
              "// Version endpoint summary", 
              "const versionDevTime = parseInt(pm.collectionVariables.get('version_dev_time') || '0');",
              "const versionProdTime = parseInt(pm.collectionVariables.get('version_prod_time') || '0');",
              "console.log('üîß Version Endpoint:');",
              "console.log('  Dev:', versionDevTime + 'ms | Prod:', versionProdTime + 'ms');",
              "if (versionDevTime && versionProdTime) {",
              "    const versionDiff = Math.abs(versionDevTime - versionProdTime);",
              "    const versionFaster = versionDevTime < versionProdTime ? 'Dev' : 'Prod';",
              "    console.log('  Difference:', versionDiff + 'ms (' + versionFaster + ' faster)');",
              "} else {",
              "    console.log('  ‚ùå Incomplete data');",
              "}",
              "",
              "// Stamps endpoint summary",
              "const stampsDevTime = parseInt(pm.collectionVariables.get('stamps_dev_time') || '0');",
              "const stampsProdTime = parseInt(pm.collectionVariables.get('stamps_prod_time') || '0');",
              "console.log('üè∑Ô∏è Stamps Endpoint (Reliable Data Range):');",
              "console.log('  Dev:', stampsDevTime + 'ms | Prod:', stampsProdTime + 'ms');",
              "if (stampsDevTime && stampsProdTime) {",
              "    const stampsDiff = Math.abs(stampsDevTime - stampsProdTime);",
              "    const stampsFaster = stampsDevTime < stampsProdTime ? 'Dev' : 'Prod';",
              "    console.log('  Difference:', stampsDiff + 'ms (' + stampsFaster + ' faster)');",
              "    ",
              "    // Performance ratio analysis",
              "    const perfRatio = Math.max(stampsDevTime, stampsProdTime) / Math.min(stampsDevTime, stampsProdTime);",
              "    if (perfRatio > 10) {",
              "        console.log('  üö® CRITICAL: >10x performance difference detected!');",
              "    } else if (perfRatio > 5) {",
              "        console.log('  ‚ö†Ô∏è WARNING: >5x performance difference detected!');",
              "    }",
              "} else {",
              "    console.log('  ‚ùå Incomplete data');",
              "}",
              "",
              "// Block endpoint summary",
              "const blockDevTime = parseInt(pm.collectionVariables.get('block_dev_time') || '0');",
              "const blockProdTime = parseInt(pm.collectionVariables.get('block_prod_time') || '0');",
              "console.log('üîó Block Endpoint (Genesis Block 779652):');",
              "console.log('  Dev:', blockDevTime + 'ms | Prod:', blockProdTime + 'ms');",
              "if (blockDevTime && blockProdTime) {",
              "    const blockDiff = Math.abs(blockDevTime - blockProdTime);",
              "    const blockFaster = blockDevTime < blockProdTime ? 'Dev' : 'Prod';",
              "    console.log('  Difference:', blockDiff + 'ms (' + blockFaster + ' faster)');",
              "} else {",
              "    console.log('  ‚ùå Incomplete data');",
              "}",
              "",
              "// Balance endpoint summary (Critical User Workflow)",
              "const balanceDevTime = parseInt(pm.collectionVariables.get('balance_dev_time') || '0');",
              "const balanceProdTime = parseInt(pm.collectionVariables.get('balance_prod_time') || '0');",
              "console.log('üí∞ Balance Endpoint (Critical User Workflow):');",
              "console.log('  Dev:', balanceDevTime + 'ms | Prod:', balanceProdTime + 'ms');",
              "if (balanceDevTime && balanceProdTime) {",
              "    const balanceDiff = Math.abs(balanceDevTime - balanceProdTime);",
              "    const balanceFaster = balanceDevTime < balanceProdTime ? 'Dev' : 'Prod';",
              "    console.log('  Difference:', balanceDiff + 'ms (' + balanceFaster + ' faster)');",
              "} else {",
              "    console.log('  ‚ùå Incomplete data');",
              "}",
              "",
              "// SRC20 Tick endpoint summary",
              "const src20TickDevTime = parseInt(pm.collectionVariables.get('src20_tick_dev_time') || '0');",
              "const src20TickProdTime = parseInt(pm.collectionVariables.get('src20_tick_prod_time') || '0');",
              "console.log('üé´ SRC20 Tick Endpoint (Token Information):');",
              "console.log('  Dev:', src20TickDevTime + 'ms | Prod:', src20TickProdTime + 'ms');",
              "if (src20TickDevTime && src20TickProdTime) {",
              "    const src20TickDiff = Math.abs(src20TickDevTime - src20TickProdTime);",
              "    const src20TickFaster = src20TickDevTime < src20TickProdTime ? 'Dev' : 'Prod';",
              "    console.log('  Difference:', src20TickDiff + 'ms (' + src20TickFaster + ' faster)');",
              "} else {",
              "    console.log('  ‚ùå Incomplete data');",
              "}",
              "",
              "console.log('\\nüîç SCHEMA DIFFERENCE ANALYSIS:');",
              "",
              "// Check each endpoint for stored schema differences",
              "const endpoints = ['health', 'version', 'stamps', 'block', 'balance', 'src20_tick'];",
              "endpoints.forEach(endpoint => {",
              "    const schemaVarName = `${endpoint}_schema_differences`;",
              "    const schemaDiffs = pm.collectionVariables.get(schemaVarName);",
              "    if (schemaDiffs) {",
              "        try {",
              "            const differences = JSON.parse(schemaDiffs);",
              "            if (differences.length > 0) {",
              "                console.log(`üö® ${endpoint.toUpperCase()} SCHEMA DIFFERENCES (${differences.length}):`);",
              "                differences.forEach(diff => {",
              "                    console.log(`  ${diff.type}: ${diff.path}`);",
              "                    if (diff.details) console.log(`    ${diff.details}`);",
              "                });",
              "                totalSchemaDifferences += differences.length;",
              "                schemaDifferencesByEndpoint.push({",
              "                    endpoint: endpoint,",
              "                    count: differences.length,",
              "                    differences: differences",
              "                });",
              "            } else {",
              "                console.log(`‚úÖ ${endpoint.toUpperCase()}: No schema differences`);",
              "            }",
              "        } catch (e) {",
              "            console.log(`‚ö†Ô∏è ${endpoint.toUpperCase()}: Could not parse schema differences`);",
              "        }",
              "    } else {",
              "        console.log(`‚ö™ ${endpoint.toUpperCase()}: No schema comparison data`);",
              "    }",
              "});",
              "",
              "if (totalSchemaDifferences === 0) {",
              "    console.log('\\n‚úÖ NO SCHEMA CHANGES DETECTED - All schemas match between dev and production');",
              "} else {",
              "    console.log(`\\nüö® TOTAL SCHEMA DIFFERENCES: ${totalSchemaDifferences} across ${schemaDifferencesByEndpoint.length} endpoints`);",
              "    console.log('üîß ACTION REQUIRED: Review schema changes for compatibility impact');",
              "}",
              "",
              "console.log('\\nüìà REGRESSION ANALYSIS:');",
              "console.log('- Tests 6 critical endpoints: health, version, stamps, block, balance, src20_tick');",
              "console.log('- Targets reliable data ranges (blocks 779652-780000)');",
              "console.log('- Genesis block 779652 used for consistent block testing');",
              "console.log('- Sort order ASC ensures same data returned from both environments');",
              "console.log('- Deep schema comparison detects: field additions/removals, type changes, nested changes');",
              "console.log('- Focus on critical user workflows: balance lookups, token information');",
              "",
              "console.log('\\n' + '='.repeat(80));",
              "",
              "pm.test('Dual endpoint comparison completed successfully', function () {",
              "    const hasHealthData = healthDevTime > 0 && healthProdTime > 0;",
              "    const hasVersionData = versionDevTime > 0 && versionProdTime > 0;",
              "    const hasDataComparison = hasHealthData || hasVersionData;",
              "    pm.expect(hasDataComparison).to.be.true;",
              "});",
              "",
              "pm.test('No critical performance regressions detected', function () {",
              "    const endpoints = [",
              "        { name: 'health', dev: healthDevTime, prod: healthProdTime },",
              "        { name: 'version', dev: versionDevTime, prod: versionProdTime },",
              "        { name: 'stamps', dev: stampsDevTime, prod: stampsProdTime },",
              "        { name: 'block', dev: blockDevTime, prod: blockProdTime },",
              "        { name: 'balance', dev: balanceDevTime, prod: balanceProdTime },",
              "        { name: 'src20_tick', dev: src20TickDevTime, prod: src20TickProdTime }",
              "    ];",
              "    ",
              "    let criticalRegressions = 0;",
              "    endpoints.forEach(endpoint => {",
              "        if (endpoint.dev > 0 && endpoint.prod > 0) {",
              "            const ratio = Math.max(endpoint.dev, endpoint.prod) / Math.min(endpoint.dev, endpoint.prod);",
              "            if (ratio > 20) { // 20x performance difference threshold",
              "                criticalRegressions++;",
              "                console.log('CRITICAL regression on', endpoint.name, ':', ratio.toFixed(1) + 'x difference');",
              "            }",
              "        }",
              "    });",
              "    ",
              "    pm.expect(criticalRegressions).to.equal(0);",
              "});"
            ]
          }
        }
      ]
    }
  ]
} 